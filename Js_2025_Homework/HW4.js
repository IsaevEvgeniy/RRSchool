// 1. Установить какие методы массивов изменяют начальное значение массива
const arr = [1, 2, 3, "a", "b", "c"];
arr.at(); // принимает значение в виде целого числа и возвращает элемент массива с данным индексом
arr.push(); // добавляет один или более элементов в конец массива и возвращает новую длину массива
arr.unshift(); // добавляет один или более элементов в начало массива и возвращает новую длину массива
arr.pop(); // удаления последнего элемента из массива и возвращает его значение
arr.shift(); // удаляет первый элемент из массива и возвращает его значение. Этот метод изменяет длину массива
arr.join(); // объединяет все элементы массива (или массивоподобного объекта) в строку
arr.indexOf(); // возвращает первый индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет
arr.lastIndexOf(); // возвращает последний индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет. Массив просматривается с конца к началу, начиная с индекса fromIndex
arr.includes(); // экземпляров Array определяет, содержит ли массив определенное значение, возвращая true или false
arr.flat(); // экземпляров Arrayвозвращает новый массив, в котором все элементы вложенных подмассивов рекурсивно "подняты" на указанный уровень
arr.concat(); // озвращает новый массив, состоящий из массива, на котором он был вызван, соединённого с другими массивами и/или значениями, переданными в качестве аргументов
arr.reverse(); // на месте следит за порядком следования элементов массива. Первый элемент массива становится последним, а последний — первым
arr.slice(); // восстановления нового массива, восстановление части исходного массива
arr.splice(); // изменяет границы массива, удаляет внешние элементы и/или добавляет новые
arr.copyWithin(); // опирует последовательность элементов массива внутри него в позицию, начинающуюся по индексу target. Копия берётся по индексам, задаваемым вторым и третьим аргументами start и end. Аргумент end является необязательным и по умолчанию равен длине массива
arr.flat(); // экземпляров Arrayвозвращает новый массив, в котором все элементы вложенных подмассивов рекурсивно "подняты" на указанный уровень

// 2. Задача с интервью
//    У вас есть массив со скобками
//    Количество элементов и последовательность может быть разной.
//    Нужно выяснить, у каждой ли скобки есть соответствующая пара (открывающая и закрывающая).
//    Решение должно работать для всех массивов внизу.

// let arr1 = ["(", ")", "(", ")", ")"];
// let arr1 = ["(", ")", "(", ")", "{", "(", "}", ")", 2, "a"];
// let arr1 = ["(", ")", "(", "(", "(", ")", "}", "(", ")", ")"];

let parentheses = 0;
let curlyBrackets = 0;

for (let i = 0; i < arr1.length; ++i) {
  if (arr1[i] === "(" && arr1[i + 1] === ")") {
    parentheses += 1;
    i++;
  } else if (arr1[i] === "{" && arr1[i + 1] === "}") {
    curlyBrackets += +1;
    i++;
  }
}

console.log(`Количество пар составляет: ${parentheses + curlyBrackets} шт.`);

// 3. Найти самое маленькое число из массива [4, 81, 3, -12, 99, 14]

let arr = [4, 81, 3, -12, 99, 14];
let min = arr[0];
for (let i = 0; i < arr.length; i++) {
  if (min > arr[i]) {
    min = arr[i];
  }
}
console.log(min);

console.log(Math.min(...arr));

// 4. Найти самое большое число из массива [4, 81, 3, -12, 99, 14]

let arr = [4, 81, 3, -12, 99, 14];
let max = arr[0];
for (let i = 0; i < arr.length; i++) {
  if (max < arr[i]) {
    max = arr[i];
  }
}
console.log(max);

console.log(Math.max(...arr));

// 5. Найти сумму всех элементов массива [[1, 2], [3, 4, 5], [6, 7, 8]]

let arr = [
  [1, 2],
  [3, 4, 5],
  [6, 7, 8],
];
let sum = 0;
for (let i = 0; i < arr.length; i++) {
  for (let j = 0; j < arr[i].length; j++) {
    sum += arr[i][j];
  }
}
console.log(sum);

const arr = [
  [1, 2],
  [3, 4, 5],
  [6, 7, 8],
].flat();
let sum = 0;
for (let i = 0; i < arr.length; i++) {
  sum += arr[i];
}
console.log(sum);

// 6. При помощи цикла for выведите чётные числа от 2 до 10

for (let i = 2; i <= 10; i += 2) {
  console.log(i);
}

// 7. Нарисуйте прямоугольный треугольник

let num = 9;
for (let i = 1; i <= num; i++) {
  if (i % 2 !== 0) {
    let stars = "";
    for (let j = 0; j < i; j++) {
      stars += "*";
    }
    console.log(stars + " ");
  }
}

// *
// * * *
// * * * * *
// * * * * * * *
// * * * * * * * * *

// 8. Нарисуйте треугольник с цифрами - лево

let num = 9;

for (let i = 0; i <= num; i++) {
  let row = "";

  for (let j = 0; j <= num - i; j++) {
    row += j + " ";
  }
  console.log(row);
}

// 0 1 2 3 4 5 6 7 8 9
// 0 1 2 3 4 5 6 7 8
// 0 1 2 3 4 5 6 7
// 0 1 2 3 4 5 6
// 0 1 2 3 4 5
// 0 1 2 3 4
// 0 1 2 3
// 0 1 2
// 0 1
// 0

// 9. Нарисуйте треугольник с цифрами - право

let num = 9;

for (let i = 0; i <= num; i++) {
  let row = "";
  for (let k = 0; k < i; k++) {
    row += "  ";
  }
  for (let j = 0; j <= num - i; j++) {
    row += j + " ";
  }
  console.log(row);
}

// 0 1 2 3 4 5 6 7 8 9
//   0 1 2 3 4 5 6 7 8
//     0 1 2 3 4 5 6 7
//       0 1 2 3 4 5 6
//         0 1 2 3 4 5
//           0 1 2 3 4
//             0 1 2 3
//               0 1 2
//                 0 1
//                   0

//  10. Есть код. Какой будет результат этого кода и почему

const numbers = [1, 2, 3, 4, 5];
let sum = 0;

for (let i = 0; i < numbers.length; i++) {
  if (i % 2 !== 0) {
    sum += numbers[i];
  }
}
console.log(sum);

// Объявляем массив:
// const numbers = [1, 2, 3, 4, 5];

// Объявляем переменную для суммы:
// let sum = 0;

// Применяем цикл с перебором массива по индексу от 0 до 4:
// for (let i = 0; i < numbers.length; i++) {

// Используем метод:
// if (i % 2 !== 0) {
// Проверяем, является ли индекс нечётным.

// Суммируем значения с нечётными индексами:
// sum += numbers[i];

// Выводим результат в консоль:
// console.log(sum);
